<!DOCTYPE HTML>
<html><head><link rel=stylesheet href="ringBuf2d.css"><script src="ringBuf2d.js"></script></head><body><div id=div></div><script>"use strict";
var cnv = document.createElement('canvas'), ctx = cnv.getContext('2d');
var dot = {w:5,h:5}, w2n = Math.log2(innerWidth / dot.w) | 0, h2n = Math.log2(innerHeight / dot.h) | 0;
cnv.width = dot.w << w2n, cnv.height = dot.h << h2n;
div.appendChild(cnv);
	
onload = function(){
var buf2d = Buf2d(w2n, h2n)
.onmove(function(dx, dy, dt){
	if( Math.hypot(dx, dy) > 8 || (dt -= 3000) > 0){ //check min range lim to allow onfill(), or max delta time latency (save dt for return)
		var x = Math.floor(dx), y = Math.floor(dy); //compute integer coord to replace picture
		ctx.drawImage(cnv, x * dot.w, y * dot.h ); //replace
		dx -= x, dy -= y; //increese dx/dy - by (int released motion) x,y - to compute accumulable motion
	}
	div.style.left = dx * dot.w + 'px'; div.style.top = dy * dot.h + 'px'; //move element by css (accumulable motion)
	return -dt; //return interval(ms>0) if you cancel and want fill buffer later (to allow onfill() return <=0 or undefined)
})
.onfill(function(x1, y1, x2, y2){
	setTimeout((function(){
		for(var arr = [], y = y1; y < y2; y++)
			for(var x = x1; x < x2; x++){
				ctx.fillStyle = 'hsl(' + x * 4 + ',50%,' + Math.abs(Math.abs(y * 4 % 200) - 100) + '%';
				ctx.fillRect( (x - this.x) * dot.w, (y - this.y) * dot.h, dot.w - 1, dot.h - 1);
				arr.push(ctx.fillStyle);
			}
		this.put(x1, y1, x2 - x1, arr);
	}).bind(this), 50 * (Math.random() + 1) ); //emulate load latensy random 50-100ms
})
.fill();
window.ontouchmove = onmousemove = function(E){
	var e = E.changedTouches || E; e.stopPropagation && e.stopPropagation(); e.preventDefault && e.preventDefault();
	if(!e.buttons)return false;
	var dx = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
	var dy = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
	buf2d.moveBy( -dx/dot.w, -dy/dot.h );
}
}
</script></body></html>
